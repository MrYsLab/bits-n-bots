{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Bits 'N Bots The Official Blog Of Mr. Y's Lab"},{"location":"2025/05/20/telemetrix-under-the-hood--part-1/","title":"Telemetrix Under The Hood  Part 1","text":"<p>Over the past few years, I've been developing the  Telemetrix family of libraries. These libraries,  designed to facilitate microcontroller programming, allow you to  control and monitor a variety of microcontrollers through a  standardized set of Python3 client APIs and associated microcontroller  servers written in C++.</p> <p>The Telemetrix architecture, with its simplicity and consistency,  is highly extensible. It empowers you to easily add new functionality and  support for future microprocessors and hardware devices, giving you complete  control over your development process.</p> <p>Except for the Raspberry Pi Pico, all Telemetrix servers are based upon Arduino Cores. This includes the server for the Raspberry Pi  Pico W. </p> <p>An Arduino Core contains all the software and tools to provide a software  abstraction  layer for a particular processor.  It includes various tools, like the gcc compiler tools, to  compile and link  the code. Using Arduino Cores allows for a high degree of commonality between  the servers, simplifies adding support for a new microprocessor, and allows for  integrating additional Arduino device libraries.</p> <p>The client APIs are designed to focus on efficiency and productivity, sharing many standard features. This makes porting code written from one microprocessor to another a breeze, saving time and effort.</p> <p>Currently, Telemetrix supports the:</p> <ul> <li>Arduino ATMega boards(UNO, Leonardo, Mega2560)</li> <li>Arduino UNO R4 Minima and WIFI</li> <li>Arduino Nano RP2040 Connect </li> <li>ESP8266</li> <li>ESP32</li> <li>Raspberry Pi Pico (Raspberry Pi C++ SDK-based)</li> <li>Raspberry Pi Pico-W</li> <li>STM32 Boards (i.e. Blackpill)</li> </ul> <p>To uncover Telemetrix internals, we will be using the HC-SR04 ultrasonic sensor feature to explore the following:</p> <ul> <li>Telemetrix Command And Message Structure.</li> <li>Telemetrix Server File Layout</li> <li>Telemetrix Client File Layout</li> </ul> <p>In the next post we will explore the Telemetrix Command And Message Structure.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/","title":"Telemetrix Under The Hood  Part 3","text":""},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#understanding-the-telemetrix-server","title":"Understanding The Telemetrix Server","text":""},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#introduction","title":"Introduction","text":"<p>Let's examine the  Telemetrix server code  for the Arduino UNO R4 Minima,</p> <p>Why select the server for the Minima and not another board?</p> <p>The Minima is one of the newer boards in the Arduino family,  so we chose it to highlight a Telemetrix server design. However, all Telemetrix servers are remarkably similar.  The discussion below would be almost identical if any other server were chosen. Once you learn about one Telemetrix server, you are fully prepared to understand them all. This post will examine the file's structure, major data structures, and internal workings.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#a-feature-reference-point","title":"A Feature Reference Point","text":"<p>One main reason for understanding the internal workings of a Telemetrix  server is to be able to add support for a new sensor or actuator.</p> <p>To this end, the HC-SR04 SONAR distance sensor illustrates the  areas of server code affected by adding sensor support. Adding actuator support is very similar to adding sensor support. </p> <p>Why the HC-SR04? Because it highlights some of the finer points of adding a new feature, such as:</p> <ul> <li>Device instantiation.</li> <li>Continuous non-blocking timed polling of the device.</li> <li>Generating reports for data changes.</li> </ul> <p>All these things will be uncovered as we proceed with the discussion. Search for the heading SONAR SIDEBAR to make the HC-SR04-specific  discussions easier to find within the post.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#using-an-established-arduino-library-for-device-support","title":"Using An Established Arduino Library For Device Support","text":"<p>When adding support for a new device, you have the choice to create your own  Arduino library or use an existing library. Using an  existing support library has many advantages.  You can evaluate the code to ensure it does not  block for long periods and provides all the desired functionality.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#sonar-sidebar","title":"SONAR SIDEBAR","text":"<p>The NewPing  library was chosen to support the HC-SR04 SONAR feature.  It is mostly non-blocking and has a straightforward API,  making its integration into Telemetrix fairly simple.</p> <p>Let's take a look at a basic example provided by NewPing.</p> <pre><code>// ---------------------------------------------------------------------------\n// Example NewPing library sketch that does a ping about 20 times per second.\n// ---------------------------------------------------------------------------\n\n#include &lt;NewPing.h&gt;\n\n#define TRIGGER_PIN  12  // Arduino pin tied to trigger pin on the ultrasonic sensor.\n#define ECHO_PIN     11  // Arduino pin tied to echo pin on the ultrasonic sensor.\n#define MAX_DISTANCE 200 // Maximum distance we want to ping for (in centimeters). Maximum sensor distance is rated at 400-500cm.\n\nNewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // NewPing setup of pins and maximum distance.\n\nvoid setup() {\n  Serial.begin(115200); // Open serial monitor at 115200 baud to see ping results.\n}\n\nvoid loop() {\n  delay(50);                     // Wait 50ms between pings (about 20 pings/sec). 29ms should be the shortest delay between pings.\n  Serial.print(\"Ping: \");\n  Serial.print(sonar.ping_cm()); // Send ping, get distance in cm and print result (0 = outside set distance range)\n  Serial.println(\"cm\");\n}\n</code></pre> <p>Essentially, an instance of NewPing is created for each SONAR sensor.  Then, a NewPing method, ping_cm(), reads the sensor.</p> <p>For HC-SR04 sensors, a read may not be performed more than  once every 29 milliseconds to get accurate reads.  That is the reason for the 50-millisecond delay in the example above.</p> <p>Telemetrix provides a non-blocking scheme to read the sensor continuously.  This scheme will be covered in the Scanning Inputs section of this document.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#telemetrix-server-file-layout","title":"Telemetrix Server File Layout","text":"<p>All Telemetrix servers use a very similar file layout.  We will use the server built for the  Arduino UNO R4 Minima for discussion purposes.</p> <p>The server code is considered \"fixed\" because it is  uploaded to the microcontroller and left unchanged. </p> <p>To change the behavior of the Arduino or other microcontroller, the  Telemetrix client sends messages to the server.  The server is implemented to wait for and interpret commands from the client and then act upon them. A command may result in continuously monitoring  a pin or device for data changes. When a data change is detected,  the server may form a report message and autonomously send the report to the client.</p> <p>We will cover the client in the next post.</p> <p>Let's explore the code.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#telemetrix-server-code-sections","title":"Telemetrix Server Code Sections","text":"<p>All Telemetrix servers are implemented using the following \"common\" sections:</p> <ol> <li>Feature Enabling Defines</li> <li>Arduino ID</li> <li>Client Command Related Defines and Support</li> <li>Server Report Related Defines</li> <li>i2c Related Defines</li> <li>Pin-Related Defines And Data Structures</li> <li>Feature Related Defines, Data Structures, and Storage Allocation</li> <li>Command Functions</li> <li>Scanning Inputs, Generating Reports, and Running Steppers</li> <li>Setup and Loop</li> </ol> <p>Both code snippets and links to the code will be used  when discussing these sections.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#feature-enabling-defines","title":"Feature Enabling Defines","text":"<p>The ability to turn a built-in feature on or off can be handy.  For example, you may turn off certain features when debugging a modified server.</p> <p>If the new feature causes the server to run out of programming memory space,  you can control the server's footprint by removing support for unneeded features.</p> <p>A typical set of server features include:</p> <ul> <li>Support SPI device communication.</li> <li>Support for i2c device communication.</li> <li>Support for 1-Wire device communication.</li> <li>Support for servo motors.</li> <li>Support for stepper motors.</li> <li>Support for HC-SR04 type ultrasonic distance sensors.</li> <li>Support for DHT-type temperature/humidity sensors.</li> </ul> <p>Let's look at the feature-enabling #defines.</p> <pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*                    FEATURE ENABLING DEFINES                      */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n\n\n// To disable a feature, comment out the desired enabling define or defines\n\n// This will allow SPI support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define SPI_ENABLED 1\n\n// This will allow OneWire support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define ONE_WIRE_ENABLED 1\n\n// This will allow DHT support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define DHT_ENABLED 1\n\n// This will allow sonar support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define SONAR_ENABLED 1\n\n// This will allow servo support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define SERVO_ENABLED 1\n\n// This will allow stepper support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n\n// Accelstepper is currently not compatible with the UNO R4 Minima\n// #define STEPPERS_ENABLED 1\n\n// This will allow I2C support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define I2C_ENABLED 1\n\n</code></pre> <p>All the features are enabled for the UNO R4 Minima except stepper motor support. The #define for this feature is commented out because  the AccelStepper library used to implement this feature does not  yet function with Arduino UNO R4 boards.</p> <p>We will implement the feature in a future article using a different stepper motor library. </p> <p>Note that when a feature is activated, the  required header files are #included.</p> <pre><code>#ifdef SERVO_ENABLED\n#include &lt;Servo.h&gt;\n#endif\n\n#ifdef SONAR_ENABLED\n#include &lt;NewPing.h&gt;\n#endif\n\n#ifdef I2C_ENABLED\n#include &lt;Wire.h&gt;\n#endif\n\n#ifdef DHT_ENABLED\n#include &lt;DHTStable.h&gt;\n#endif\n\n#ifdef SPI_ENABLED\n#include &lt;SPI.h&gt;\n#endif\n\n#ifdef ONE_WIRE_ENABLED\n#include &lt;OneWire.h&gt;\n#endif\n\n#ifdef STEPPERS_ENABLED\n#include &lt;AccelStepper.h&gt;\n#endif\n\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#sonar-sidebar_1","title":"SONAR SIDEBAR","text":"<p>For the HC-SR04, the feature is enabled with:</p> <pre><code>// This will allow sonar support to be compiled into the sketch.\n// Comment this out to save sketch space for the UNO\n#define SONAR_ENABLED 1\n</code></pre> <p>With the SONAR feature enabled, the server includes the NewPing Arduino library for feature support.</p> <pre><code>#ifdef SONAR_ENABLED\n#include &lt;NewPing.h&gt;\n#endif\n</code></pre> <p>When adding a new feature, you must add the new feature #define and use the #define to  include any required support libraries.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#arduino-id","title":"Arduino ID","text":"<p>For microcontrollers that use a serial/USB data transport,  Telemetrix defaults to using an auto-discovery scheme to find the  COM port to which the microcontroller is connected.</p> <p>The Arduino ID aids in automatic microcontroller discovery and connection.</p> <p>Optionally, you may also manually specify the COM port in your application.  However, this is not always effective because the operating system's COM port  assignment may change dynamically from run to run.</p> <pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*                    Arduino ID                      */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n// This value must be the same as specified when instantiating the\n// telemetrix client. The client defaults to a value of 1.\n// This value is used for the client to auto-discover and to\n// connect to a specific board regardless of the current com port\n// it is currently connected to.\n\n#define ARDUINO_ID 1\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#client-command-related-defines-and-support","title":"Client Command Related Defines and Support","text":"<p>The Arduino UNO R4 Minima has 58 client commands defined.  Each command that the server supports has a command ID.</p> <p>The command IDs must match those mirrored in the Python client API code.</p> <pre><code>\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*         Client Command Related Defines and Support               */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n// Commands Sent By The Client\n\n\n// Add commands retaining the sequential numbering.\n// The order of commands here must be maintained in the command_table.\n#define SERIAL_LOOP_BACK 0\n#define SET_PIN_MODE 1\n#define DIGITAL_WRITE 2\n#define ANALOG_WRITE 3\n#define MODIFY_REPORTING 4 // mode(all, analog, or digital), pin, enable or disable\n#define GET_FIRMWARE_VERSION 5\n#define ARE_U_THERE 6\n#define SERVO_ATTACH 7\n#define SERVO_WRITE 8\n#define SERVO_DETACH 9\n#define I2C_BEGIN 10\n#define I2C_READ 11\n#define I2C_WRITE 12\n#define SONAR_NEW 13\n#define DHT_NEW 14\n#define STOP_ALL_REPORTS 15\n#define SET_ANALOG_SCANNING_INTERVAL 16\n#define ENABLE_ALL_REPORTS 17\n#define RESET 18\n#define SPI_INIT 19\n#define SPI_WRITE_BLOCKING 20\n#define SPI_READ_BLOCKING 21\n#define SPI_SET_FORMAT 22\n#define SPI_CS_CONTROL 23\n#define ONE_WIRE_INIT 24\n#define ONE_WIRE_RESET 25\n#define ONE_WIRE_SELECT 26\n#define ONE_WIRE_SKIP 27\n#define ONE_WIRE_WRITE 28\n#define ONE_WIRE_READ 29\n#define ONE_WIRE_RESET_SEARCH 30\n#define ONE_WIRE_SEARCH 31\n#define ONE_WIRE_CRC8 32\n#define SET_PIN_MODE_STEPPER 33\n#define STEPPER_MOVE_TO 34\n#define STEPPER_MOVE 35\n#define STEPPER_RUN 36\n#define STEPPER_RUN_SPEED 37\n#define STEPPER_SET_MAX_SPEED 38\n#define STEPPER_SET_ACCELERATION 39\n#define STEPPER_SET_SPEED 40\n#define STEPPER_SET_CURRENT_POSITION 41\n#define STEPPER_RUN_SPEED_TO_POSITION 42\n#define STEPPER_STOP 43\n#define STEPPER_DISABLE_OUTPUTS 44\n#define STEPPER_ENABLE_OUTPUTS 45\n#define STEPPER_SET_MINIMUM_PULSE_WIDTH 46\n#define STEPPER_SET_ENABLE_PIN 47\n#define STEPPER_SET_3_PINS_INVERTED 48\n#define STEPPER_SET_4_PINS_INVERTED 49\n#define STEPPER_IS_RUNNING 50\n#define STEPPER_GET_CURRENT_POSITION 51\n#define STEPPER_GET_DISTANCE_TO_GO 52\n#define STEPPER_GET_TARGET_POSITION 53\n#define GET_FEATURES 54\n#define SONAR_SCAN_OFF 55\n#define SONAR_SCAN_ON 56\n#define BOARD_HARD_RESET 57\n</code></pre> <p>Each command ID has an associated command handler to process the command.  Each command handler is initially specified using forward referencing to simplify compilation. </p> <pre><code>/* Command Forward References*/\n\n// If you add a new command, you must add the command handler\n// here as well.\n\nextern void serial_loopback();\n\nextern void set_pin_mode();\n\nextern void digital_write();\n\nextern void analog_write();\n\nextern void modify_reporting();\n\nextern void get_firmware_version();\n\nextern void are_you_there();\n\nextern void servo_attach();\n\nextern void servo_write();\n\nextern void servo_detach();\n\nextern void i2c_begin();\n\nextern void i2c_read();\n\nextern void i2c_write();\n\nextern void sonar_new();\n\nextern void dht_new();\n\nextern void stop_all_reports();\n\nextern void set_analog_scanning_interval();\n\nextern void enable_all_reports();\n\nextern void reset_data();\n\nextern void init_pin_structures();\n\nextern void init_spi();\n\nextern void write_blocking_spi();\n\nextern void read_blocking_spi();\n\nextern void set_format_spi();\n\nextern void spi_cs_control();\n\nextern void onewire_init();\n\nextern void onewire_reset();\n\nextern void onewire_select();\n\nextern void onewire_skip();\n\nextern void onewire_write();\n\nextern void onewire_read();\n\nextern void onewire_reset_search();\n\nextern void onewire_search();\n\nextern void onewire_crc8();\n\nextern void set_pin_mode_stepper();\n\nextern void stepper_move_to();\n\nextern void stepper_move();\n\nextern void stepper_run();\n\nextern void stepper_run_speed();\n\nextern void stepper_set_max_speed();\n\nextern void stepper_set_acceleration();\n\nextern void stepper_set_speed();\n\nextern void stepper_get_distance_to_go();\n\nextern void stepper_get_target_position();\n\nextern void stepper_get_current_position();\n\nextern void stepper_set_current_position();\n\nextern void stepper_run_speed_to_position();\n\nextern void stepper_stop();\n\nextern void stepper_disable_outputs();\n\nextern void stepper_enable_outputs();\n\nextern void stepper_set_minimum_pulse_width();\n\nextern void stepper_set_3_pins_inverted();\n\nextern void stepper_set_4_pins_inverted();\n\nextern void stepper_set_enable_pin();\n\nextern void stepper_is_running();\n\nextern void get_features();\n\nextern void sonar_disable();\n\nextern void sonar_enable();\n\nextern void board_hard_reset();\n</code></pre> <p>The actual handlers are defined further down the  file. </p> <p>IMPORTANT NOTE:</p> <p>The command IDs are used as an index to reference a command in the command  table array. Therefore, when adding a new command, add a new ID at the bottom of the command defines.</p> <p>The command IDs are mirrored in the Telemetrix client Python API.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#the-command-table","title":"The Command Table","text":"<p>We must add each new command to the command table.</p> <pre><code>// When adding a new command update the command_table.\n// The command length is the number of bytes that follow\n// the command byte itself, and does not include the command\n// byte in its length.\n\n// The command_func is a pointer the command's function.\nstruct command_descriptor\n{\n    // a pointer to the command processing function\n    void (*command_func)(void);\n};\n\n\n// An array of pointers to the command functions.\n// The list must be in the same order as the command defines.\n\ncommand_descriptor command_table[] =\n        {\n                {&amp;serial_loopback},\n                {&amp;set_pin_mode},\n                {&amp;digital_write},\n                {&amp;analog_write},\n                {&amp;modify_reporting},\n                {&amp;get_firmware_version},\n                {&amp;are_you_there},\n                {&amp;servo_attach},\n                {&amp;servo_write},\n                {&amp;servo_detach},\n                {&amp;i2c_begin},\n                {&amp;i2c_read},\n                {&amp;i2c_write},\n                {&amp;sonar_new},\n                {&amp;dht_new},\n                {&amp;stop_all_reports},\n                {&amp;set_analog_scanning_interval},\n                {&amp;enable_all_reports},\n                {&amp;reset_data},\n                {&amp;init_spi},\n                {&amp;write_blocking_spi},\n                {&amp;read_blocking_spi},\n                {&amp;set_format_spi},\n                {&amp;spi_cs_control},\n                {&amp;onewire_init},\n                {&amp;onewire_reset},\n                {&amp;onewire_select},\n                {&amp;onewire_skip},\n                {&amp;onewire_write},\n                {&amp;onewire_read},\n                {&amp;onewire_reset_search},\n                {&amp;onewire_search},\n                {&amp;onewire_crc8},\n                {&amp;set_pin_mode_stepper},\n                {&amp;stepper_move_to},\n                {&amp;stepper_move},\n                {&amp;stepper_run},\n                {&amp;stepper_run_speed},\n                {&amp;stepper_set_max_speed},\n                {&amp;stepper_set_acceleration},\n                {&amp;stepper_set_speed},\n                (&amp;stepper_set_current_position),\n                (&amp;stepper_run_speed_to_position),\n                (&amp;stepper_stop),\n                (&amp;stepper_disable_outputs),\n                (&amp;stepper_enable_outputs),\n                (&amp;stepper_set_minimum_pulse_width),\n                (&amp;stepper_set_enable_pin),\n                (&amp;stepper_set_3_pins_inverted),\n                (&amp;stepper_set_4_pins_inverted),\n                (&amp;stepper_is_running),\n                (&amp;stepper_get_current_position),\n                {&amp;stepper_get_distance_to_go},\n                (&amp;stepper_get_target_position),\n                (&amp;get_features),\n                (&amp;sonar_disable),\n                (&amp;sonar_enable),\n                (&amp;board_hard_reset),\n        };\n\n\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#sonar-sidebar_2","title":"SONAR SIDEBAR","text":"<p>Three methods support the SONAR feature: sonar_new, sonar_disable, and sonar_enable. The Command Functions section of this post will discuss these.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#server-report-related-defines","title":"Server Report Related Defines","text":"<p>A server report transmits information, such as an input value change or a reply  to a client informational request.</p> <p>Each report contains a report ID. These IDs are defined here.</p> <p>When adding an ID for a new report, add it before DEBUG_PRINT_REPORT. </p> <pre><code>// Reports sent to the client\n\n#define DIGITAL_REPORT DIGITAL_WRITE\n#define ANALOG_REPORT ANALOG_WRITE\n#define FIRMWARE_REPORT 5\n#define I_AM_HERE 6\n#define SERVO_UNAVAILABLE 7\n#define I2C_TOO_FEW_BYTES_RCVD 8\n#define I2C_TOO_MANY_BYTES_RCVD 9\n#define I2C_READ_REPORT 10\n#define SONAR_DISTANCE 11\n#define DHT_REPORT 12\n#define SPI_REPORT 13\n#define ONE_WIRE_REPORT 14\n#define STEPPER_DISTANCE_TO_GO 15\n#define STEPPER_TARGET_POSITION 16\n#define STEPPER_CURRENT_POSITION 17\n#define STEPPER_RUNNING_REPORT 18\n#define STEPPER_RUN_COMPLETE_REPORT 19\n#define FEATURES 20\n#define DEBUG_PRINT 99\n</code></pre> <p>For example, if we want to create a new report called NEW_REPORT, we would add it after the FEATURES report, and NEW_REPORT would be assigned an ID of 21.</p> <pre><code>#define STEPPER_RUNNING_REPORT 18\n#define STEPPER_RUN_COMPLETE_REPORT 19\n#define FEATURES 20\n#define NEW_REPORT 21  // The newly added report\n#define DEBUG_PRINT 99\n</code></pre> <p>Like command IDs, report IDs are mirrored in the Telemetrix Python API.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#i2c-related-defines","title":"I2C Related Defines","text":"<p>This section  contains #defines used for managing i2c ports. It specifies  the i2c SDA and SCL pins.</p> <p>Note that the Arduino UNO R4 Minima has only one I2C port. Its one  I2C bus is marked with SCL and SDA. It is shared with A4 (SDA)  and A5 (SCL), which owners of previous UNOs are familiar with.</p> <p>The #defines for a second I2C port are included for possible future development, but  are not supported by the current version of the Arduino UNO R4 Minima.</p> <pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*                     i2c Related Defines*/\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n/**********************************/\n/* i2c defines */\n\n#ifdef I2C_ENABLED\n// uncomment out the next line to create a 2nd i2c port\n// #define SECOND_I2C_PORT\n\n#ifdef SECOND_I2C_PORT\n// Change the pins to match SDA and SCL for your board\n#define SECOND_I2C_PORT_SDA PB3\n#define SECOND_I2C_PORT_SCL PB10\n\nTwoWire Wire2(SECOND_I2C_PORT_SDA, SECOND_I2C_PORT_SCL);\n#endif\n\n// a pointer to an active TwoWire object\nTwoWire *current_i2c_port;\n#endif\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#pin-related-defines-and-data-structures","title":"Pin Related Defines And Data Structures","text":"<p>This section contains the definitions for arrays of pin descriptors for analog and  digital pins.</p> <p>Each pin descriptor contains information such as the pin number, if its mode is input or output, whether the pin is enabled to generate a report, and the last value reported.</p> <pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*           Pin Related Defines And Data Structures                */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n\n// Pin mode definitions\n\n// INPUT defined in Arduino.h = 0\n// OUTPUT defined in Arduino.h = 1\n// INPUT_PULLUP defined in Arduino.h = 2\n// The following are defined for arduino_telemetrix (AT)\n#define AT_ANALOG 3\n#define AT_MODE_NOT_SET 255\n\n// maximum number of pins supported\n#define MAX_DIGITAL_PINS_SUPPORTED 14\n#define MAX_ANALOG_PINS_SUPPORTED 6\n\n\n// Analog input pins are defined from\n// A0 - A5.\n\n\n// To translate a pin number from an integer value to its analog pin number\n// equivalent, this array is used to look up the value to use for the pin.\nint analog_read_pins[6] = {A0, A1, A2, A3, A4, A5};\n\n// a descriptor for digital pins\nstruct pin_descriptor\n{\n    byte pin_number;\n    byte pin_mode;\n    bool reporting_enabled; // If true, then send reports if an input pin\n    int last_value;         // Last value read for input mode\n};\n\n// an array of digital_pin_descriptors\npin_descriptor the_digital_pins[MAX_DIGITAL_PINS_SUPPORTED];\n\n// a descriptor for analog pins\nstruct analog_pin_descriptor\n{\n    byte pin_number;\n    byte pin_mode;\n    bool reporting_enabled; // If true, then send reports if an input pin\n    int last_value;         // Last value read for input mode\n    int differential;       // difference between current and last value needed\n                            // to generate a report\n};\n\n// an array of analog_pin_descriptors\nanalog_pin_descriptor the_analog_pins[MAX_ANALOG_PINS_SUPPORTED];\n\nunsigned long current_millis;  // for analog input loop\nunsigned long previous_millis; // for analog input loop\nuint8_t analog_sampling_interval = 19; // in milliseconds\n\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#feature-related-defines-data-structures-and-storage-allocation","title":"Feature Related Defines, Data Structures, And Storage Allocation","text":"<p>This section contains the code to manage features such as  servos, DHT temperature/humidity devices, sonar distance sensors,  stepper motors, and onewire devices.</p> <pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*  Feature Related Defines, Data Structures and Storage Allocation */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n// servo management\n#ifdef SERVO_ENABLED\nServo servos[MAX_SERVOS];\n\n// this array allows us to retrieve the servo object\n// associated with a specific pin number\nbyte pin_to_servo_index_map[MAX_SERVOS];\n#endif\n\n// HC-SR04 Sonar Management\n#define MAX_SONARS 6\n\n#ifdef SONAR_ENABLED\nstruct Sonar\n{\n    uint8_t trigger_pin;\n    unsigned int last_value;\n    NewPing *usonic;\n};\n\n// an array of sonar objects\nSonar sonars[MAX_SONARS];\n\nbyte sonars_index = 0; // index into sonars struct\n\n// used for scanning the sonar devices.\nbyte last_sonar_visited = 0;\n#endif //SONAR_ENABLED\n\nunsigned long sonar_current_millis;  // for analog input loop\nunsigned long sonar_previous_millis; // for analog input loop\n\n#ifdef SONAR_ENABLED\nuint8_t sonar_scan_interval = 33;    // Milliseconds between sensor pings\n// (29ms is about the min to avoid = 19;\n#endif\n\n// DHT Management\n#define MAX_DHTS 6                // max number of devices\n#define READ_FAILED_IN_SCANNER 0  // read request failed when scanning\n#define READ_IN_FAILED_IN_SETUP 1 // read request failed when initially setting up\n\n#ifdef DHT_ENABLED\nstruct DHT\n{\n    uint8_t pin;\n    uint8_t dht_type;\n    unsigned int last_value;\n    DHTStable *dht_sensor;\n};\n\n// an array of dht objects\nDHT dhts[MAX_DHTS];\n\nbyte dht_index = 0; // index into dht struct\n\nunsigned long dht_current_millis;      // for analog input loop\nunsigned long dht_previous_millis;     // for analog input loop\nunsigned int dht_scan_interval = 2000; // scan dht's every 2 seconds\n#endif // DHT_ENABLED\n\n\n/* OneWire Object*/\n\n// a pointer to a OneWire object\n#ifdef ONE_WIRE_ENABLED\nOneWire *ow = NULL;\n#endif\n\n#define MAX_NUMBER_OF_STEPPERS 4\n\n// stepper motor data\n#ifdef STEPPERS_ENABLED\nAccelStepper *steppers[MAX_NUMBER_OF_STEPPERS];\n\n// stepper run modes\nuint8_t stepper_run_modes[MAX_NUMBER_OF_STEPPERS];\n#endif\n\n### \n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#sonar-sidebar_3","title":"SONAR SIDEBAR","text":"<p>Specific to HC-SR04 management is this section:</p> <pre><code>// HC-SR04 Sonar Management\n#define MAX_SONARS 6\n\n#ifdef SONAR_ENABLED\nstruct Sonar\n{\n    uint8_t trigger_pin;\n    unsigned int last_value;\n    NewPing *usonic;\n};\n\n// an array of sonar objects\nSonar sonars[MAX_SONARS];\n\nbyte sonars_index = 0; // index into sonars struct\n\n// used for scanning the sonar devices.\nbyte last_sonar_visited = 0;\n#endif //SONAR_ENABLED\n\n#ifdef SONAR_ENABLED\nuint8_t sonar_scan_interval = 33;    // Milliseconds between sensor pings\n// (29ms is about the min to avoid = 19;\n#endif\n</code></pre> <p>The server supports up to 6 sensors. Each sensor has an entry  into an array that stores its trigger pin, the last value read,  and a pointer to its associated NewPing instance.</p> <p>The scan interval is set to 33 milliseconds for accurate distance measurement.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#command-functions","title":"Command Functions","text":"<p>This section of code  contains the implementations of the command handlers.</p> <p>Each handler dereferences the data specific to each command.</p> <p>Let's look at the handler for a digital write.</p> <pre><code>void digital_write()\n{\n    byte pin;\n    byte value;\n    pin = command_buffer[0];\n    value = command_buffer[1];\n    digitalWrite(pin, value);\n}\n</code></pre> <p>The command buffer contains the information sent from the client, including the pin  number and the requested value for that pin.</p> <p>The Arduino Core digital write command, digitalWrite,  is called using the information sent from the client.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#scanning-inputs-generating-reports-and-running-steppers","title":"Scanning Inputs, Generating Reports, And Running Steppers","text":"<p>After setting a pin as input, Telemetrix polls the pin for any changes. It does so for digital inputs,  analog inputs, HC-SR04 distance sensors, and DHT temperature sensors, and if required,  will keep a stepper motor running.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#sonar-sidebar_4","title":"SONAR SIDEBAR","text":"<p>Let's look at the code for the sonar scanner.</p> <pre><code>void scan_sonars()\n{\n#ifdef SONAR_ENABLED\n    unsigned int distance;\n\n    if (sonars_index)\n    {\n        sonar_current_millis = millis();\n        if (sonar_current_millis - sonar_previous_millis &gt; sonar_scan_interval)\n        {\n            sonar_previous_millis = sonar_current_millis;\n            distance = sonars[last_sonar_visited].usonic-&gt;ping_cm();\n            if (distance != sonars[last_sonar_visited].last_value)\n            {\n                sonars[last_sonar_visited].last_value = distance;\n\n                // byte 0 = packet length\n                // byte 1 = report type\n                // byte 2 = trigger pin number\n                // byte 3 = distance high order byte\n                // byte 4 = distance low order byte\n                byte report_message[5] = {4, SONAR_DISTANCE, sonars[last_sonar_visited].trigger_pin,\n                                          (byte)(distance &gt;&gt; 8), (byte)(distance &amp; 0xff)\n                };\n                Serial.write(report_message, 5);\n            }\n            last_sonar_visited++;\n            if (last_sonar_visited == sonars_index)\n            {\n                last_sonar_visited = 0;\n            }\n        }\n    }\n#endif\n}\n</code></pre> <p>The scan_sonars function first checks to see if any sensors were enabled by checking  the sonars_index variable.</p> <p>Next, it determines whether the scanning interval has elapsed and updates the  sonar_previous_millis variable to the current time.</p> <p>It then calls the ping_cm function of the usonic instance associated with the  sensor to retrieve the distance.</p> <p>If the current distance read differs from the last distance read, it updates  the last_value variable to the current distance read, assembles, and sends a  report message to the client.</p> <p>Finally, it updates the sonars_index to the next sensor to be scanned.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#setup-and-loop","title":"Setup and Loop","text":"<pre><code>/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n/*                    Setup And Loop                                */\n/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\nvoid setup()\n{\n    // set up features for enabled features\n#ifdef ONE_WIRE_ENABLED\n    features |= ONEWIRE_FEATURE;\n#endif\n\n#ifdef DHT_ENABLED\n    features |= DHT_FEATURE;\n#endif\n\n#ifdef STEPPERS_ENABLED\n    features |= STEPPERS_FEATURE;\n#endif\n\n#ifdef SPI_ENABLED\n    features |= SPI_FEATURE;\n#endif\n\n#ifdef SERVO_ENABLED\n    features |= SERVO_FEATURE;\n#endif\n\n#ifdef SONAR_ENABLED\n    features |= SONAR_FEATURE;\n#endif\n\n#ifdef I2C_ENABLED\n    features |= I2C_FEATURE;\n#endif\n\n#ifdef STEPPERS_ENABLED\n\n    for ( int i = 0; i &lt; MAX_NUMBER_OF_STEPPERS; i++) {\n        stepper_run_modes[i] = STEPPER_STOP ;\n    }\n#endif\n\n    init_pin_structures();\n\n    Serial.begin(115200);\n\n    pinMode(13, OUTPUT);\n    for( int i = 0; i &lt; 4; i++){\n        digitalWrite(13, HIGH);\n        delay(250);\n        digitalWrite(13, LOW);\n        delay(250);\n    }\n}\n\nvoid loop()\n{\n    // keep processing incoming commands\n    get_next_command();\n\n    if (!stop_reports)\n    { // stop reporting\n        scan_digital_inputs();\n        scan_analog_inputs();\n\n#ifdef SONAR_ENABLED\n        if(sonar_reporting_enabled ){\n            scan_sonars();\n        }\n#endif\n\n#ifdef DHT_ENABLED\n        scan_dhts();\n#endif\n#ifdef STEPPERS_ENABLED\n        run_steppers();\n#endif\n    }\n}\n</code></pre>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#setup","title":"Setup","text":"<p>The setup function checks for all enabled features and stores then stores the information in the features byte.</p> <p>It builds the pin structures, starts the serial link, and then flashes the board LED 4 times.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#loop","title":"Loop","text":"<p>The loop function checks to see if a client command needs to be processed by calling get_next_command.</p> <p>If reporting is enabled, it calls the various scanners and, if necessary, sends the requested commands  to the configured stepper motors.</p>"},{"location":"2025/05/22/telemetrix-under-the-hood--part-3/#the-next-posting","title":"The Next Posting","text":"<p>We've completed the discussion of the Telemetrix server file.  In the next post, we will discuss the Python API class.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/","title":"Telemetrix Under The Hood  Part 4","text":""},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-telemetrix-python-client-api","title":"The Telemetrix Python Client API","text":"<p>This post will explore the implementation of the Telemetrix Python client API for the Arduino UNO R4 Minima. To help focus the discussion,  we will again use the HC-SR04 SONAR distance sensor feature as an example. Please search for the SONAR SIDEBAR heading to make the discussions about this  feature easier to find.</p> <p>Although this discussion is specific to the Arduino UNO R4 Minima client API, all Telemetrix client APIs are very similar, so you should be able to apply the information  in this post to any other Telemetrix client API.</p> <p>The Telemetrix framework aims to provide an experience as close to  real-time as possible. To achieve this goal, a Telemetrix client implements concurrency and callback schemes.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#concurrency","title":"Concurrency","text":"<p>Concurrency refers to a system's ability to execute multiple tasks  through simultaneous execution or time-sharing (context switching),  sharing resources, and managing interactions. It improves responsiveness,  throughput, and scalability.</p> <p>A Telemetrix client has three primary operations competing for the processor's attention.</p> <p>Those operations are:</p> <ul> <li>Process the on-demand API command requests.</li> <li>Receive and buffer reports sent from the Telemetrix server over the transport link.</li> <li>Process the data contained in the buffered reports.</li> </ul> <p>Concurrency allows the client to send command messages to the server while retrieving  and buffering server reports and processing the buffered  reports. All these operations are performed with minimal blocking to  ensure the application is highly reactive.</p> <p>Concurrency is implemented using one of two Python concurrency schemes.</p> <p>For the  TelemetrixUnoR4Minima threaded API,  Python threading and a  Python deque  are deployed. A deque, which stands for double-ended queue, is a  data structure that allows you to add and remove items from either end of the queue. It is thread-safe and part of the Python standard library.</p> <p>For the TelemetrixUnoR4MinimaAio asynchronous API,  Python asyncio is used to implement  concurrency.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#minimizing-telemetrix-clientserver-messaging-overhead-via-callbacks","title":"Minimizing Telemetrix Client/Server Messaging Overhead Via Callbacks","text":"<p>The Telemetrix protocol uses a callback scheme to minimize the data  communication overhead between the client and server.</p> <p>The alternative to using callbacks is to poll the server periodically  for changes in input data.  This approach is unacceptable because it is highly inefficient.</p> <p>Not only does a command message need to be formed and  transmitted, but the client, without blocking,  must also wait for the server to create a  response and send a report message back.</p> <p>During all this messaging and waiting, a data change event on a  pin or device may be missed.</p> <p>Instead of polling, a Telemetrix server autonomously monitors input pins and only  transmits a report to the client when the pin's state or value changes.  Because the server continuously monitors its input pins and devices, a data change is less likely to be missed. A report is immediately sent to the client  when a change is detected.</p> <p>When callbacks are used instead of polling, bidirectional communication between the  client and server is significantly reduced by 50% or more when compared to polling.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#what-is-a-callback","title":"What Is A Callback?","text":"<p>Simply put, a callback is a function  passed as an argument to another function. This action is sometimes referred to as registering a callback.</p> <p>Callbacks are registered in the following telemetrix API calls:</p> <ul> <li>i2c_read</li> <li>i2c_read_restart_transmission</li> <li>loop_back</li> <li>set_pin_mode_analog_input</li> <li>set_pin_mode_dht</li> <li>set_pin_mode_digital_input</li> <li>set_pin_mode_digital_input_pullup</li> <li>set_pin_mode_sonar</li> <li>spi_read_blocking</li> </ul> <p>Callback functions are user-written pieces of code that process server report data and are part of a Telemetrix client application.</p> <p>Let's look at an example that sets a pin as a digital input pin and  prints pin state changes. The pin is connected to a pushbutton switch, and switch debouncing is provided within  the callback function as part of this application.</p> <pre><code>import sys\nimport time\n\nfrom telemetrix_uno_r4.minima.telemetrix_uno_r4_minima import telemetrix_uno_r4_minima\n\"\"\"\nMonitor a digital input pin\n\"\"\"\n\n\"\"\"\nSetup a pin for digital input and monitor its changes\n\"\"\"\n\n# Set up a pin for analog input and monitor its changes\nDIGITAL_PIN = 12  # arduino pin number\n\n# Callback data indices\nCB_PIN_MODE = 0\nCB_PIN = 1\nCB_VALUE = 2\nCB_TIME = 3\n\n# variable to hold the last time a button state changed\ndebounce_time = time.time()\n\n\ndef the_callback(data):\n    \"\"\"\n    A callback function to report data changes.\n    This will print the pin number, its reported value and\n    the date and time when the change occurred\n\n    :param data: [pin_type, pin_number, pin_value, raw_time_stamp]\n    \"\"\"\n    global debounce_time\n\n    # if the time from the last event change is &gt; .2 seconds, the input is debounced\n    if data[CB_TIME] - debounce_time &gt; .3:\n        date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[CB_TIME]))\n        print(f'Pin: {data[CB_PIN]} Value: {data[CB_VALUE]} Time Stamp: {date}')\n        debounce_time = data[CB_TIME]\n\n\ndef digital_in(my_board, pin):\n    \"\"\"\n     This function establishes the pin as a\n     digital input. Any changes on this pin will\n     be reported through the call back function.\n\n     :param my_board: a telemetrix instance\n     :param pin: Arduino pin number\n     \"\"\"\n\n    # set the pin mode\n    my_board.set_pin_mode_digital_input(pin, the_callback)\n\n    print('Enter Control-C to quit.')\n    # my_board.enable_digital_reporting(12)\n    try:\n        while True:\n            time.sleep(.0001)\n    except KeyboardInterrupt:\n        board.shutdown()\n        sys.exit(0)\n\n\nboard = telemetrix_uno_r4_minima.TelemetrixUnoR4Minima()\ntry:\n    digital_in(board, DIGITAL_PIN)\nexcept KeyboardInterrupt:\n    board.shutdown()\n    sys.exit(0)\n\n</code></pre> <p>Let's begin by looking at the callback function.</p> <pre><code>def the_callback(data):\n    \"\"\"\n    A callback function to report data changes.\n    This will print the pin number, its reported value and\n    the date and time when the change occurred\n\n    :param data: [pin, current reported value, pin_mode, timestamp]\n    \"\"\"\n    global debounce_time\n\n    # if the time from the last event change is &gt; .3 seconds, the input is debounced\n    if data[CB_TIME] - debounce_time &gt; .3:\n        date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[CB_TIME]))\n        print(f'Pin: {data[CB_PIN]} Value: {data[CB_VALUE]} Time Stamp: {date}')\n        debounce_time = data[CB_TIME]\n</code></pre> <p>All callback functions have the same signature. That signature is a single parameter  called  data. </p> <p>You are free to name the callback anything you like. For this example, we called the callback function the_callback.</p> <p>The data parameter is always a Python list, but the contents  vary by report type. The last element of the list is always a time stamp,  except for the loop_back report, which does not contain a time stamp.</p> <p>When an API call requires a callback function, the list's contents are  specified in the API documentation. For example, for set_pin_mode_digital_input, data contains the following list: [pin_type, pin_number, pin_value, raw_time_stamp]</p> <p>The pin type identifies the pin type, such as DHT, analog, digital, etc. The pin  number is the pin being monitored, the pin_value is  the current reported value, and the raw_time_stamp is the time stamp of  the event and the time that the client received the report.</p> <p>In the example, we create offset variables to help dereference the list </p> <pre><code># Callback data indices\nCB_PIN_MODE = 0\nCB_PIN = 1\nCB_VALUE = 2\nCB_TIME = 3\n</code></pre> <p>Let's look at how the callback dereferences and uses the list contents.</p> <p>The first thing the callback does is check if the time from the last event change is  greater than .3 seconds. If it is, the input is debounced, and we can proceed.</p> <p>Next, it converts the time stamp to a human-readable date and time.</p> <p>Finally, it prints the pin number, the reported value, and the change's date and time.</p> <p>We keep the callback code as simple as possible to avoid blocking.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#registering-the-callback","title":"Registering The Callback","text":"<pre><code># set the pin mode\n    my_board.set_pin_mode_digital_input(pin, the_callback)\n</code></pre> <p>The call back is registered in the call to set_pin_mode_digital_input.</p> <p>The callback function is automatically called when a digital input report is received.</p> <p>The scope of a callback is only limited by how you wish to use it. You may have a single callback function to handle all reports from  a single pin_type or a callback function for each pin.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-telemetrix-client-api-source-files","title":"The Telemetrix Client API Source Files","text":"<p>Let's look at the file tree for the telemetrix-uno-r4 project.</p> <pre><code>telemetrix_uno_r4\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 minima\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 telemetrix_uno_r4_minima\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 private_constants.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 telemetrix_uno_r4_minima.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 telemetrix_uno_r4_minima_aio\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 private_constants.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 telemetrix_aio_serial.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 telemetrix_uno_r4_minima_aio.py\n\u2514\u2500\u2500 wifi\n    \u251c\u2500\u2500 telemetrix_uno_r4_wifi\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 private_constants.py\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 telemetrix_uno_r4_wifi.py\n    \u2514\u2500\u2500 telemetrix_uno_r4_wifi_aio\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 private_constants.py\n        \u251c\u2500\u2500 telemetrix_aio_ble.py\n        \u251c\u2500\u2500 telemetrix_aio_serial.py\n        \u251c\u2500\u2500 telemetrix_aio_socket.py\n        \u2514\u2500\u2500 telemetrix_uno_r4_wifi_aio.py\n</code></pre> <p>This project consists of two main modules: one for the Arduino R4 Minima  microcontroller and the other for the Arduino R4 WIFI microcontroller.</p> <p>The minima module contains two submodules: telemetrix_uno_r4_minima for  the threaded API and telemetrix_uno_r4_minima_aio  for the asynchronous API.</p> <p>The wifi module also contains two submodules:  one for the threaded API, telemetrix_uno_r4_wifi, and the other for  the asynchronous API, telemetrix_uno_r4_wifi_aio.</p> <p>All four submodules contain a file called private_constants.py and a file that  defines the API class definition.  For the threaded Minima API,  this file is called telemetrix_uno_r4_minima.py, and we will look at  it after discussing the private constants file.</p> <p>The asyncio sub-modules contain one or more additional files that support a specific  data-link transport.</p> <p>This discussion will focus on the threaded API,  telemetrix_uno_r4_minima,  for the  Arduino R4 Minima microcontroller.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-private-constants-file","title":"The Private Constants File","text":"<p>All Telemetrix clients \"define their constants\" in a file  called private_constants.py.</p> <p>There isn't a built-in way to declare constants in Python like in some other languages  (e.g., using const in C++ or final in Java).  However, by convention, variables intended to be constants are named  using all uppercase letters with underscores separating words.  This convention serves as a signal that these values should not be changed.</p> <p>Let's look at private_constants.py for the Arduino R4 Minima microcontroller.</p> <pre><code>class PrivateConstants:\n    \"\"\"\n    This class contains a set of constants for telemetrix internal use .\n    \"\"\"\n\n    # commands\n    # send a loop back request - for debugging communications\n    LOOP_COMMAND = 0\n    SET_PIN_MODE = 1  # set a pin to INPUT/OUTPUT/PWM/etc\n    DIGITAL_WRITE = 2  # set a single digital pin value instead of entire port\n    ANALOG_WRITE = 3\n    MODIFY_REPORTING = 4\n    GET_FIRMWARE_VERSION = 5\n    ARE_U_THERE = 6  # Arduino ID query for auto-detect of telemetrix connected boards\n    SERVO_ATTACH = 7\n    SERVO_WRITE = 8\n    SERVO_DETACH = 9\n    I2C_BEGIN = 10\n    I2C_READ = 11\n    I2C_WRITE = 12\n    SONAR_NEW = 13\n    DHT_NEW = 14\n    STOP_ALL_REPORTS = 15\n    SET_ANALOG_SCANNING_INTERVAL = 16\n    ENABLE_ALL_REPORTS = 17\n    RESET = 18\n    SPI_INIT = 19\n    SPI_WRITE_BLOCKING = 20\n    SPI_READ_BLOCKING = 21\n    SPI_SET_FORMAT = 22\n    SPI_CS_CONTROL = 23\n    ONE_WIRE_INIT = 24\n    ONE_WIRE_RESET = 25\n    ONE_WIRE_SELECT = 26\n    ONE_WIRE_SKIP = 27\n    ONE_WIRE_WRITE = 28\n    ONE_WIRE_READ = 29\n    ONE_WIRE_RESET_SEARCH = 30\n    ONE_WIRE_SEARCH = 31\n    ONE_WIRE_CRC8 = 32\n    SET_PIN_MODE_STEPPER = 33\n    STEPPER_MOVE_TO = 34\n    STEPPER_MOVE = 35\n    STEPPER_RUN = 36\n    STEPPER_RUN_SPEED = 37\n    STEPPER_SET_MAX_SPEED = 38\n    STEPPER_SET_ACCELERATION = 39\n    STEPPER_SET_SPEED = 40\n    STEPPER_SET_CURRENT_POSITION = 41\n    STEPPER_RUN_SPEED_TO_POSITION = 42\n    STEPPER_STOP = 43\n    STEPPER_DISABLE_OUTPUTS = 44\n    STEPPER_ENABLE_OUTPUTS = 45\n    STEPPER_SET_MINIMUM_PULSE_WIDTH = 46\n    STEPPER_SET_ENABLE_PIN = 47\n    STEPPER_SET_3_PINS_INVERTED = 48\n    STEPPER_SET_4_PINS_INVERTED = 49\n    STEPPER_IS_RUNNING = 50\n    STEPPER_GET_CURRENT_POSITION = 51\n    STEPPER_GET_DISTANCE_TO_GO = 52\n    STEPPER_GET_TARGET_POSITION = 53\n    GET_FEATURES = 54\n    SONAR_DISABLE = 55\n    SONAR_ENABLE = 56\n    BOARD_HARD_RESET = 57\n\n    # reports\n    # debug data from Arduino\n    DIGITAL_REPORT = DIGITAL_WRITE\n    ANALOG_REPORT = ANALOG_WRITE\n    FIRMWARE_REPORT = GET_FIRMWARE_VERSION\n    I_AM_HERE_REPORT = ARE_U_THERE\n    SERVO_UNAVAILABLE = SERVO_ATTACH\n    I2C_TOO_FEW_BYTES_RCVD = 8\n    I2C_TOO_MANY_BYTES_RCVD = 9\n    I2C_READ_REPORT = 10\n    SONAR_DISTANCE = 11\n    DHT_REPORT = 12\n    SPI_REPORT = 13\n    ONE_WIRE_REPORT = 14\n    STEPPER_DISTANCE_TO_GO = 15\n    STEPPER_TARGET_POSITION = 16\n    STEPPER_CURRENT_POSITION = 17\n    STEPPER_RUNNING_REPORT = 18\n    STEPPER_RUN_COMPLETE_REPORT = 19\n    FEATURES = 20\n    DEBUG_PRINT = 99\n\n    TELEMETRIX_VERSION = \"1.1.1\"\n\n    # reporting control\n    REPORTING_DISABLE_ALL = 0\n    REPORTING_ANALOG_ENABLE = 1\n    REPORTING_DIGITAL_ENABLE = 2\n    REPORTING_ANALOG_DISABLE = 3\n    REPORTING_DIGITAL_DISABLE = 4\n\n    # Pin mode definitions\n    AT_INPUT = 0\n    AT_OUTPUT = 1\n    AT_INPUT_PULLUP = 2\n    AT_ANALOG = 3\n    AT_SERVO = 4\n    AT_SONAR = 5\n    AT_DHT = 6\n    AT_MODE_NOT_SET = 255\n\n    # maximum number of digital pins supported\n    NUMBER_OF_DIGITAL_PINS = 100\n\n    # maximum number of analog pins supported\n    NUMBER_OF_ANALOG_PINS = 20\n\n    # maximum number of sonars allowed\n    MAX_SONARS = 6\n\n    # maximum number of DHT devices allowed\n    MAX_DHTS = 6\n\n    # DHT Report sub-types\n    DHT_DATA = 0\n    DHT_ERROR = 1\n\n    # feature masks\n    ONEWIRE_FEATURE = 0x01\n    DHT_FEATURE = 0x02\n    STEPPERS_FEATURE = 0x04\n    SPI_FEATURE = 0x08\n    SERVO_FEATURE = 0x10\n    SONAR_FEATURE = 0x20\n</code></pre> <p>Many of the private constant file values are mirrored on the server.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#command-ids","title":"Command IDs","text":"<p>The first section of the file defines the command IDs. These values must match those  defined in the server. When adding a new feature, update the server with a command  ID of the same value.  Add the new feature ID after the last command ID in the file. </p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar","title":"SONAR SIDEBAR","text":"<p>There are three command IDs associated with the HC-SR04 device.</p> <ul> <li>SONAR_NEW - commands the server to add a new entry to its   \"sonar table\" and to start monitoring the device immediately.</li> <li>SONAR_DISABLE - commands the server to stop sending sonar reports.</li> <li>SONAR_ENABLE - commands the server to send sonar reports.</li> </ul>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#report-ids","title":"Report IDs","text":"<p>The next section of the file defines the report IDs. These values must match those  defined in the server. When adding a new report, update the server with a report ID of the same value.  Add the new report ID just before the DEBUG_PRINT ID.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_1","title":"SONAR SIDEBAR","text":"<p>The report ID for the HC-SR04 device is 11.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#version-number","title":"Version Number","text":"<p>The version number comes next. It specifies the current version of the Telemetrix client.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#reporting-control","title":"Reporting Control","text":"<p>Reporting control defines the values that can be used to disable or enable reporting.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#pin-mode-definitions","title":"Pin Mode Definitions","text":"<p>This section defines the pin mode values.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#maximum-number-of-digital-pins","title":"Maximum Number of Digital Pins","text":"<p>This value defines the maximum number of digital pins supported by the client.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#maximum-number-of-analog-pins","title":"Maximum Number of Analog Pins","text":"<p>This value defines the maximum number of analog pins supported by the client.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#maximum-number-of-specific-devices-supported","title":"Maximum Number of Specific Devices supported","text":"<p>The maximum number of SONARs and DHT temperature/humidity sensors supported by the  client.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_2","title":"SONAR SIDEBAR","text":"<p>The client supports a maximum of 6 SONAR devices.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#dht-report-sub-types","title":"DHT Report Sub-Types","text":"<p>A DHT report can contain a valid temperature/humidity reading,  or the device may report an error. This section defines the two sub-types.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#feature-masks","title":"Feature Masks","text":"<p>This section defines the feature masks.  These masks allow us to determine which features the client supports. </p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_3","title":"SONAR SIDEBAR","text":"<p>The feature mask for the Servo device is 0x20.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-api-class-definition","title":"The API Class Definition","text":"<p>All Telemetrix API class definitions are very similar. Once you understand the API class definition telemetrix_uno_r4_minima.py, you will be prepared to understand all other Telemetrix API class definitions.</p> <p>Let's look at telemetrix_uno_r4_minima.py section by section.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#init-method","title":"Init Method","text":"<pre><code>class TelemetrixUnoR4Minima(threading.Thread):\n    \"\"\"\n    This class exposes and implements the telemetrix API.\n    It uses threading to accommodate concurrency.\n    It includes the public API methods as well as\n    a set of private methods.\n\n    \"\"\"\n\n    # noinspection PyPep8,PyPep8,PyPep8\n    def __init__(self, com_port=None, arduino_instance_id=1,\n                 arduino_wait=1, sleep_tune=0.000001,\n                 shutdown_on_exception=True, hard_reset_on_shutdown=True):\n\n        \"\"\"\n\n        :param com_port: e.g. COM3 or /dev/ttyACM0.\n                         Only use if you wish to bypass auto com port\n                         detection.\n\n        :param arduino_instance_id: Match with the value installed on the\n                                    arduino-telemetrix sketch.\n\n        :param arduino_wait: Amount of time to wait for an Arduino to\n                             fully reset itself.\n\n        :param sleep_tune: A tuning parameter (typically not changed by user)\n\n        :param shutdown_on_exception: call shutdown before raising\n                                      a RunTimeError exception, or\n                                      receiving a KeyboardInterrupt exception\n\n        :param hard_reset_on_shutdown: reset the board on shutdown\n\n        \"\"\"\n\n        # initialize threading parent\n        threading.Thread.__init__(self)\n\n        # create the threads and set them as daemons so\n        # that they stop when the program is closed\n\n        # create a thread to interpret received serial data\n        self.the_reporter_thread = threading.Thread(target=self._reporter)\n        self.the_reporter_thread.daemon = True\n\n        self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)\n\n        self.the_data_receive_thread.daemon = True\n\n        # flag to allow the reporter and receive threads to run.\n        self.run_event = threading.Event()\n</code></pre> <p>The init method begins by creating the reporter and receive threads and sets them as  daemons. It also  creates the run_event flag for thread synchronization.</p> <p>Next, it saves all the parameters passed to the init method.</p> <pre><code>        # save input parameters as instance variables\n        self.com_port = com_port\n        self.arduino_instance_id = arduino_instance_id\n        self.arduino_wait = arduino_wait\n        self.sleep_tune = sleep_tune\n        self.shutdown_on_exception = shutdown_on_exception\n        self.hard_reset_on_shutdown = hard_reset_on_shutdown\n</code></pre> <p>then, it creates a dequeue object to hold the received data.</p> <pre><code># create a deque to receive and process data from the arduino\n        self.the_deque = deque()\n</code></pre> <p>A report dispatch table is created as a dictionary. Each entry in the dictionary  is a tuple of the report ID as the key and the report processing function as its value.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#adding-a-new-report","title":"Adding A New Report","text":"<p>When adding a new report, add a new entry to the report dispatch table.</p> <pre><code>\n        # The report_dispatch dictionary is used to process\n        # incoming report messages by looking up the report message\n        # and executing its associated processing method.\n\n        self.report_dispatch = {}\n\n        # To add a command to the command dispatch table, append here.\n        self.report_dispatch.update(\n            {PrivateConstants.LOOP_COMMAND: self._report_loop_data})\n        self.report_dispatch.update(\n            {PrivateConstants.DEBUG_PRINT: self._report_debug_data})\n        self.report_dispatch.update(\n            {PrivateConstants.DIGITAL_REPORT: self._digital_message})\n        self.report_dispatch.update(\n            {PrivateConstants.ANALOG_REPORT: self._analog_message})\n        self.report_dispatch.update(\n            {PrivateConstants.FIRMWARE_REPORT: self._firmware_message})\n        self.report_dispatch.update({PrivateConstants.I_AM_HERE_REPORT: self._i_am_here})\n        self.report_dispatch.update(\n            {PrivateConstants.SERVO_UNAVAILABLE: self._servo_unavailable})\n        self.report_dispatch.update(\n            {PrivateConstants.I2C_READ_REPORT: self._i2c_read_report})\n        self.report_dispatch.update(\n            {PrivateConstants.I2C_TOO_FEW_BYTES_RCVD: self._i2c_too_few})\n        self.report_dispatch.update(\n            {PrivateConstants.I2C_TOO_MANY_BYTES_RCVD: self._i2c_too_many})\n        self.report_dispatch.update(\n            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})\n        self.report_dispatch.update({PrivateConstants.DHT_REPORT: self._dht_report})\n        self.report_dispatch.update(\n            {PrivateConstants.SPI_REPORT: self._spi_report})\n        self.report_dispatch.update(\n            {PrivateConstants.ONE_WIRE_REPORT: self._onewire_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_DISTANCE_TO_GO:\n                 self._stepper_distance_to_go_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_TARGET_POSITION:\n                 self._stepper_target_position_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_CURRENT_POSITION:\n                 self._stepper_current_position_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_RUNNING_REPORT:\n                 self._stepper_is_running_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_RUN_COMPLETE_REPORT:\n                 self._stepper_run_complete_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_DISTANCE_TO_GO:\n                 self._stepper_distance_to_go_report})\n        self.report_dispatch.update(\n            {PrivateConstants.STEPPER_TARGET_POSITION:\n                 self._stepper_target_position_report})\n        self.report_dispatch.update(\n            {PrivateConstants.FEATURES:\n                 self._features_report})\n</code></pre>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_4","title":"SONAR SIDEBAR","text":"<p>The HC-SR04 device is added to the report dispatch table, as shown below.</p> <pre><code>self.report_dispatch.update(\n            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})\n</code></pre> <p>Storage is allocated for the various callback functions. </p> <pre><code>        # dictionaries to store the callbacks for each pin\n        self.analog_callbacks = {}\n\n        self.digital_callbacks = {}\n\n        self.i2c_callback = None\n        self.i2c_callback2 = None\n\n        self.i2c_1_active = False\n        self.i2c_2_active = False\n\n        self.spi_callback = None\n\n        self.onewire_callback = None\n\n        self.cs_pins_enabled = []\n\n        # the trigger pin will be the key to retrieve\n        # the callback for a specific HC-SR04\n        self.sonar_callbacks = {}\n\n        self.sonar_count = 0\n\n        self.dht_callbacks = {}\n\n        self.dht_count = 0\n</code></pre> <p>In addition, an empty list, self.the cs_pins_enabled variable is created to store valid SPI chip select pins.</p> <p>Also,  feature-specific variables, such as self.dht_count,  store the number of enabled DHT modules.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#example-hc-sr04","title":"Example - HC-SR04","text":""},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_5","title":"SONAR SIDEBAR","text":"<p>For the HC-SR04 SONAR device, the following variables are created:</p> <ul> <li>sonar_callbacks - A dictionary to store the callback  functions for each SONAR with the  trigger pin is used as a key.</li> <li>sonar_count - A counter to keep track of the number of registered sonars.</li> </ul> <p>The init method continues allocating storage. The code's comments explain these  instance  variables.</p> <pre><code>        # serial port in use\n        self.serial_port = None\n\n        # flag to indicate we are in shutdown mode\n        self.shutdown_flag = False\n\n        # debug loopback callback method\n        self.loop_back_callback = None\n\n        # firmware version to be stored here\n        self.firmware_version = []\n\n        # reported arduino instance id\n        self.reported_arduino_id = []\n\n        # reported features\n        self.reported_features = 0\n\n        # flag to indicate if i2c was previously enabled\n        self.i2c_enabled = False\n\n        # flag to indicate if spi is initialized\n        self.spi_enabled = False\n\n        # flag to indicate if onewire is initialized\n        self.onewire_enabled = False\n\n</code></pre> <p>Next, the init method starts the reporter thread, and the data receive thread.</p> <pre><code>        self.the_reporter_thread.start()\n        self.the_data_receive_thread.start()\n</code></pre> <p>The data_receive_thread is implemented in the __serial_receiver_ method.</p> <p>The reporter thread is implemented using the  __reporter_ method.</p> <p>Since Python does not support the concept of a private method, a single underscore before the method name serves as a visual indicator that the method is to be considered private. </p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-_serial_receiver","title":"The _serial_receiver","text":"<p>The _serial_receiver method reads data from the server,  byte by byte, and appends each byte to the deque.</p> <pre><code>    def _serial_receiver(self):\n        \"\"\"\n        Thread to continuously check for incoming data.\n        When a byte comes in, place it onto the deque.\n        \"\"\"\n        self.run_event.wait()\n\n        # Don't start this thread if using a tcp/ip transport\n\n        while self._is_running() and not self.shutdown_flag:\n            # we can get an OSError: [Errno9] Bad file descriptor when shutting down\n            # just ignore it\n            try:\n                if self.serial_port.inWaiting():\n                    c = self.serial_port.read()\n                    self.the_deque.append(ord(c))\n                    # print(ord(c))\n                else:\n                    time.sleep(self.sleep_tune)\n                    # continue\n            except OSError:\n                pass\n\n</code></pre>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-_reporter","title":"The _reporter","text":"<p>The reporter thread checks to see if anything is on the deque.</p> <p>It assembles the response_data list containing the  report data passed to an appropriate callback function.</p> <pre><code>    def _reporter(self):\n        \"\"\"\n        This is the reporter thread. It continuously pulls data from\n        the deque. When a full message is detected, that message is\n        processed.\n        \"\"\"\n        self.run_event.wait()\n\n        while self._is_running() and not self.shutdown_flag:\n            if len(self.the_deque):\n                # response_data will be populated with the received data for the report\n                response_data = []\n                packet_length = self.the_deque.popleft()\n                if packet_length:\n                    # get all the data for the report and place it into response_data\n                    for i in range(packet_length):\n                        while not len(self.the_deque):\n                            time.sleep(self.sleep_tune)\n                        data = self.the_deque.popleft()\n                        response_data.append(data)\n\n                    # print(f'response_data {response_data}')\n\n                    # get the report type and look up its dispatch method\n                    # here we pop the report type off of response_data\n                    report_type = response_data.pop(0)\n                    # print(f' reported type {report_type}')\n\n                    # retrieve the report handler from the dispatch table\n                    dispatch_entry = self.report_dispatch.get(report_type)\n\n                    # if there is additional data for the report,\n                    # it will be contained in response_data\n                    # noinspection PyArgumentList\n                    dispatch_entry(response_data)\n                    continue\n                else:\n                    if self.shutdown_on_exception:\n                        self.shutdown()\n                    raise RuntimeError(\n                        'A report with a packet length of zero was received.')\n            else:\n                time.sleep(self.sleep_tune)\n</code></pre>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#establishing-a-transport-link","title":"Establishing A Transport Link","text":"<p>In this code section, an attempt is made to establish a serial transport link.</p> <p>When instantiating TelemetrixUnoR4Minima, if the com_port parameter is not specified, an attempt is made to find a connected device by calling  _find_arduino.</p> <p>If the com_port parameter is specified, then an attempt to  connect to that com_port is made.</p> <p>If the connection is successful, then threads are allowed to run.</p> <pre><code>       # using the serial link\n        if not self.com_port:\n            # user did not specify a com_port\n            try:\n                self._find_arduino()\n            except KeyboardInterrupt:\n                if self.shutdown_on_exception:\n                    self.shutdown()\n        else:\n            # com_port specified - set com_port and baud rate\n            try:\n                self._manual_open()\n            except KeyboardInterrupt:\n                if self.shutdown_on_exception:\n                    self.shutdown()\n\n        if self.serial_port:\n            print(\n                f\"Arduino compatible device found and connected to {self.serial_port.port}\")\n\n            self.serial_port.reset_input_buffer()\n            self.serial_port.reset_output_buffer()\n\n        # no com_port found - raise a runtime exception\n        else:\n            if self.shutdown_on_exception:\n                self.shutdown()\n            raise RuntimeError('No Arduino Found or User Aborted Program')\n\n        # allow the threads to run\n        self._run_threads()\n\n</code></pre>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#retrieving-the-firmware-version-from-the-server-and-proceeding","title":"Retrieving The Firmware Version From The Server And Proceeding","text":"<p>The client sends a command to retrieve the server's version number.  If successful, it will retrieve the features supported by the server.</p> <p>Finally, a command is sent to reset the server's working data structures.</p> <pre><code>        # get telemetrix firmware version and print it\n        print('\\nRetrieving Telemetrix4UnoR4Minima firmware ID...')\n        self._get_firmware_version()\n        if not self.firmware_version:\n            if self.shutdown_on_exception:\n                self.shutdown()\n            raise RuntimeError(f'Telemetrix4UnoR4Minima firmware version')\n\n        else:\n\n            print(f'Telemetrix4UnoR4Minima firmware version: {self.firmware_version[0]}.'\n                  f'{self.firmware_version[1]}.{self.firmware_version[2]}')\n        command = [PrivateConstants.ENABLE_ALL_REPORTS]\n        self._send_command(command)\n\n        # get the features list\n        command = [PrivateConstants.GET_FEATURES]\n        self._send_command(command)\n        time.sleep(.2)\n\n        # Have the server reset its data structures\n        command = [PrivateConstants.RESET]\n        self._send_command(command)\n</code></pre>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-api-command-methods","title":"The API Command Methods","text":"<p>The next section of the code implements all the API command methods, including any \"private\" support methods.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_6","title":"SONAR SIDEBAR","text":"<p>The code for the three HC-SR04 commands may be found here:</p> <ul> <li>set_pin_mode_sonar</li> <li>sonar_enable</li> <li>sonar_disable</li> </ul>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-report-handler-methods","title":"The Report Handler Methods","text":"<p>This section of the code implements all the report handlers.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#sonar-sidebar_7","title":"SONAR SIDEBAR","text":"<p>The code for the SONAR distance report is implemented here.</p>"},{"location":"2025/05/23/telemetrix-under-the-hood--part-4/#the-next-posting","title":"The Next Posting","text":"<p>We've completed the discussion of the Telemetrix API client.  In the next post, we will summarize how to add new features.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/","title":"Telemetrix Under The Hood Part 2","text":""},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#understanding-telemetrix-messaging","title":"Understanding Telemetrix Messaging","text":"<p>A Telemetrix Python client and a Telemetrix microprocessor-resident server communicate by exchanging messages over a data transport link. </p> <p>The type of transport link that is used is dependent upon the capabilities of the server hardware.</p> <p>For example, this is a serial/USB link for the Arduino UNO R4 Minima.  For the Arduino UNO R4 WIFI, Serial/USB, WIFI, and BLE links are supported.</p> <p>Message creation, interpretation, and transfer are performed behind  the scenes and are hidden from the application developer. Therefore,  when creating your application, you need not be concerned with internal messaging details.</p> <p>However, if you wish to extend Telemetrix's functionality,  you will need to understand the details of Telemetrix messaging.</p> <p>This posting will look at the two message types and their formats.</p> <p>In subsequent postings, we will investigate the details of  message creation, interpretation, and transference.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#message-types","title":"Message Types","text":""},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#command-messages","title":"Command Messages","text":"<p>Command messages are sent from the client application to the server to  request that the server take action on the client's behalf. For example,  you may set a digital output pin to the HIGH state. When writing a Telemetrix Python client application, the application  calls digital_write, and the API code will form and transfer the message to perform the request.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#report-messages","title":"Report Messages","text":"<p>Report messages are sent from the server to the client. For example,  the server forms a report message whenever a digital input pin changes state. It autonomously sends the report message over the data transport to the  client application for processing by the pin's associated callback function.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#message-format","title":"Message Format","text":"<p>Both command and report messages use identical variable-length message formats. </p> <p>A message consists of three components:</p> <ul> <li>Packet length</li> <li>Message ID</li> <li>Message Data</li> </ul>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#packet-length","title":"Packet Length","text":"<p>The packet length is the number of bytes in the message, not including the packet length.</p> <p>The packet length is one byte in length.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#message-id","title":"Message ID","text":"<p>The message ID is one byte in length and contains the command ID  for command messages and the  report ID for report messages.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#message-data","title":"Message Data","text":"<p>The message data portion contains any data necessary to  process the message.  It is a variable number of bytes in length.</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#message-example","title":"Message Example","text":""},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#client-command-message","title":"Client Command Message","text":"<p>Let's look at the message generated by the Python API when the application calls the digital_write method.</p> <p>Here is the source code for digital_write:</p> <pre><code>def digital_write(self, pin, value):\n    \"\"\"\n    Set the specified pin to the specified value.\n\n    :param pin: arduino pin number\n\n    :param value: pin value (1 or 0)\n\n    \"\"\"\n\n    command = [PrivateConstants.DIGITAL_WRITE, pin, value]\n    self._send_command(command)\n</code></pre> <p>The method takes two parameters. A pin number and a pin value.</p> <p>The command message is initially formed as a Python list, with the command ID, followed by the pin number, and finally  with the pin output value.</p> <p>So, if we wish to set digital pin 8 to a value of 1, the command message will contain</p> <p>[2, 8, 1]</p> <p>The first byte, 2, is the command ID, 8 is the pin number, and 1 is the pin state.</p> <pre><code>    def _send_command(self, command):\n        \"\"\"\n        This is a private utility method.\n\n\n        :param command:  command data in the form of a list\n\n        \"\"\"\n        # the length of the list is added at the head\n        command.insert(0, len(command))\n        send_message = bytes(command)\n\n        if self.serial_port:\n            try:\n                self.serial_port.write(send_message)\n            except SerialException:\n                if self.shutdown_on_exception:\n                    self.shutdown()\n                raise RuntimeError('write fail in _send_command')\n        else:\n            raise RuntimeError('No serial port set.')\n</code></pre> <p>The __send_command_ method automatically calculates the length of the command in bytes  and inserts the length into the command message. For this example, the command length  is three bytes. It inserts the length at position zero of the list, so the full packet to be sent across the link is:</p> <p>[3, 2, 8, 1]</p>"},{"location":"2025/05/21/telemetrix-under-the-hood-part-2/#server-report-message","title":"Server Report Message","text":"<p>The server assembles report messages in a similar fashion</p> <pre><code>void scan_digital_inputs() {\n    byte value;\n\n    // report message\n\n    // byte 0 = packet length\n    // byte 1 = report type\n    // byte 2 = pin number\n    // byte 3 = value\n    byte report_message[4] = { 3, DIGITAL_REPORT, 0, 0 };\n\n    for (int i = 0; i &lt; MAX_DIGITAL_PINS_SUPPORTED; i++) {\n        if (the_digital_pins[i].pin_mode == INPUT || the_digital_pins[i].pin_mode == INPUT_PULLUP) {\n            if (the_digital_pins[i].reporting_enabled) {\n                // if the value changed since last read\n                value = (byte)digitalRead(the_digital_pins[i].pin_number);\n                if (value != the_digital_pins[i].last_value) {\n                    the_digital_pins[i].last_value = value;\n                    report_message[2] = (byte)i;\n                    report_message[3] = value;\n                    client.write(report_message, 4);\n                    delay(1);\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>As an example, the code above creates a report for each digital input pin with a detected state change.</p> <p>In the next post, we will explore the Telemetrix server.</p>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/","title":"Telemetrix Under The Hood Part 5","text":""},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#summarizing-adding-new-features","title":"Summarizing - Adding New Features","text":"<p>Let's quickly summarize the steps needed to add new features to Telemetrix.</p> <ul> <li>Have a clear understanding of Telemetrix messaging.</li> <li>Select an Appropriate support library for    your device.</li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#adding-a-new-command","title":"Adding A New Command","text":"<ul> <li>Select a new command ID for the device.</li> <li> </li> <li> </li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#server-changes","title":"Server Changes","text":"<ul> <li>Add this ID to the server code.</li> <li>Add a #define for the new feature.</li> <li>Select a name for the new command handler and add this to the forward      references.</li> <li>Add the new command handler name to the command descriptor table.</li> <li>Write the implementation code for the new device.</li> <li>Update the firmware version number.</li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#client-api-changes","title":"Client API Changes","text":"<ul> <li>Add the new command ID to the client's private constants file.</li> <li>Update the client version number.</li> <li>If the new feature requires instance-level storage, allocate it in the init    method.</li> <li>Write and add the new implementation code as a method to the API class.</li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#adding-a-new-report","title":"Adding A New Report","text":"<ul> <li>Select a new report ID.</li> <li> </li> <li> </li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#server-changes_1","title":"Server Changes","text":"<ul> <li>Add this ID to the server code.</li> <li>If the new feature requires persistent storage, add it to the server file.</li> <li>To continuously monitor the device, write a  polling function using the device      library you selected above.</li> <li>Add the polling function to the loop function.</li> <li>Optionally, you can write a one-shot function to poll the device.</li> </ul>"},{"location":"2025/05/25/telemetrix-under-the-hood-part-5/#client-api-changes_1","title":"Client API Changes","text":"<ul> <li>Add the ID to the client API private constants file</li> <li>Add any storage you might need to handle the report</li> <li>Write a report handler method and add it to the API class.</li> <li>Add a new entry into the report dispatch dictionary.</li> </ul>"},{"location":"2023/12/14/welcome/","title":"Welcome","text":"<p>Welcome To My Latest Blog This is my third attempt at blog hosting. My first attempt was  Mr. Y's Lab Notes.  There is a lot of good information on this blog from some of my earliest projects,  but as you will plainly see, navigation leaves much to be desired,  and there is some strange web page formatting.</p> <p>My second attempt at blogging was  Bots In Pieces.  Keeping the blog generator code  up to date was a real challenge. This resulted in some of the  navigation links leading to nowhere. Again, lots of good information to be found there.</p> <p>And now, my third attempt. I've been using  Mkdocs for Material  to document my most recent projects  and found it highly stable and easy to use. Now that they support blog creation,  I will give it a go. My hope is that it will encourage me to blog on a more regular  basis than I have in the past. Stay tuned!</p>"},{"location":"archive/2025/","title":"2025","text":""},{"location":"archive/2023/","title":"2023","text":""},{"location":"category/telemetrix-internals/","title":"Telemetrix Internals","text":""},{"location":"category/welcome/","title":"Welcome","text":""}]}